#include "Bellman_Ford.h"

//Конструктор 1 - Взятие матрицы графа из файла.
Bellman_Ford::Bellman_Ford(string namefile)
{
	ifstream fin;
	fin.open(namefile); //Открываем файл.
	if (!fin.is_open()) //Проверка на то, смогли ли мы открыть наш файл.
	{
		cout << "***************************************************************************************************" << endl;
		cout << "Ошибка открытия файла." << endl;
		cout << "Программа завершает работу. Пожалуйста, создайте файл ''Weighted graph.txt''." << endl;
		cout << "***************************************************************************************************" << endl;
		exit(1);//Завершаем работу программы.
	}
	else
	{
		cout << "***************************************************************************************************" << endl;
		cout << "Файл открыт." << endl;
		vector<int> temp;//Времменный вектор, который необходим для заполнения матрицы смежности.
		while (!fin.eof())//Цикл работает до тех пор, пока не дойдет до конца файла.
		{
			char end_line;
			string str;
			fin >> str;
			int weight = stoi(str);//Преобразование типа строки в целочисленынй тип. (В строке хранится вес ребра).
			temp.push_back(weight);
			fin.get(end_line);
			if (end_line == '\n') //10 - код перехода на новую строку. 10 = '\n'. (вместо '\n' можно исполькозовать код 10)
			{
				Matrix.push_back(temp);
				temp.clear();
			}
		}
		Matrix.push_back(temp);
		temp.clear();
		cout << "Матрица смежности успешно считана из файла." << endl;
	};
	cout << "Файл закрыт." << endl;
	fin.close();//закрываем файл.
	cout << "***************************************************************************************************" << endl;
}

//Конструктор 2 - Задание матрицы в программе (ввод одного числа, создатся матрица NxN и начнется заполение случайными числами).
Bellman_Ford::Bellman_Ford(int size_matrix)
{
	for (int i = 0; i < size_matrix; i++)
	{
		vector<int> temp;//Времменный вектор, который необходим для заполнения матрицы смежности.
		for (int j = 0; j < size_matrix; j++)
		{
			temp.push_back(rand() % 100 - 5);
		}
		Matrix.push_back(temp);
	}
}

//Конструктор 3 - Матрица будет скопированна из основной программы. (Передаваемая матрица должна быть квадратной).
Bellman_Ford::Bellman_Ford(vector<vector<int>> mat)
{
	Matrix = mat;
}

vector<int> Bellman_Ford::get_row(int number_row)
{
	vector<int> row;
	if (number_row > 0 && number_row <= Matrix.size())
	{
		row = Matrix[number_row - 1];
	}
	else
	{
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		cout << "Строки c номером " << number_row << " нету в матрице. Будет возвращенна 1-ая строка.";
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		row = Matrix[0];
	}
	return row;
}

vector<int> Bellman_Ford::get_column(int number_column)
{
	vector<int> column;
	if (number_column > 0 && number_column <= Matrix.size())
	{
		for (int i = 0; i < Matrix.size(); i++)
		{
			column.push_back(Matrix[i][number_column - 1]);
		}
	}
	else
	{
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		cout << "Столбца c номером " << number_column << " нету в матрице. Будет возвращен 1-ый столбец.";
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		for (int i = 0; i < Matrix.size(); i++)
		{
			column.push_back(Matrix[i][0]);
		}
	}
	return column;
}

void Bellman_Ford::set_row(int number_row, vector<int> row)
{
	if (row.size() > Matrix.size())
	{
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		cout << "В передаваемой строке есть проблема. Она больше, чем строки в матрице. Из передоваемой строки, будут взяты только первые N элементов (N-размерность матрицы).";
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		for (int i = row.size(); i > Matrix.size(); i--)
		{
			row.pop_back();
		}
	}
	else
	{
		if (row.size() < Matrix.size())
		{
			cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
			cout << "В передаваемой строке есть проблема. Она меньше, чем строки в матрице. Передаваемая строка будет дополнена нулями.";
			cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
			for (int i = row.size(); i < Matrix.size(); i++)
			{
				row.push_back(0);
			}
		}
	}
	if (number_row > 0 && number_row <= Matrix.size())
	{
		Matrix[number_row - 1] = row;
	}
	else
	{
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		cout << "В матрице нет строки c номером " << number_row << ". Будет заменена 1-ая строка.";
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		Matrix[0] = row;
	}
}

void Bellman_Ford::set_column(int number_column, vector<int> column)
{
	if (column.size() > Matrix.size())
	{
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		cout << "В передаваемом столбце есть проблема. Он больше, чем столбцы в матрице. Из передоваемого столбца, будут взяты только первые N элементов (N-размерность матрицы).";
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		for (int i = column.size(); i > Matrix.size(); i--)
		{
			column.pop_back();
		}
	}
	else
	{
		if (column.size() < Matrix.size())
		{
			cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
			cout << "В передаваемом столбце есть проблема. Он меньше, чем столбцы в матрице. Передаваемый столбец будет дополнен нулями.";
			cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
			for (int i = column.size(); i < Matrix.size(); i++)
			{
				column.push_back(0);
			}
		}
	}
	if (number_column > 0 && number_column <= Matrix.size())
	{
		for (int i = 0; i < Matrix.size(); i++)
		{
			Matrix[i][number_column - 1] = column[i];
		}
	}
	else
	{
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		cout << "В матрице нет столбца c номером " << number_column << ". Будет заменён 1-ый столбец.";
		cout << endl << "///////////////////////////////////////////////////////////////////////////////////////////////////" << endl;
		for (int i = 0; i < Matrix.size(); i++)
		{
			Matrix[i][0] = column[i];
		}
	}
}

void Bellman_Ford::print_Matrix()
{
	cout << "---------------------------------------------------------------------------------------------------" << endl;
	for (int i = 0; i < Matrix.size(); i++)
	{
		for (int j = 0; j < Matrix[i].size(); j++)
		{
			cout << Matrix[i][j] << "\t";
		}
		cout << endl;
	}
	cout << "---------------------------------------------------------------------------------------------------" << endl;
}